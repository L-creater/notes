## 非阻塞io

1. 输入操作，包括read、readv、recv、recvfrom、recvmsg共5个函数。如果某个进程对一个阻塞进程的TCP套接字调用这些输入函数之一，而且该套接字的接收缓冲区中没有数据可读，该进程将投入睡眠，直到有数据到达。

   而非阻塞的套接字，如果输入操作不能被满足，相应调用将立即返回一个EWPULDBLOCK错误。

2. 输出操作：包括write、writev、send、sendto、和sendmesg共5个函数。对于一个TCP套接字，内核将从应用进程的缓冲区到该套接字的发送缓冲区复制数据。对于阻塞的套接字，如果其发送缓冲区中没有空间，进程将被投入睡眠，知道有空间为止。

   非阻塞套接字，如果发送缓冲区中没有空间，输出函数调用将立即返回一个EWPULDBLOCK错误。

3. 接受外来连接，即accept函数。如果对一个阻塞的套接字调用accept函数，并且尚无新的连接到达，调用进程将被投入睡眠。

4. 

   对一个非阻塞的套接字调用accept函数，并且尚无新的连接到达，accept立即返回一个EWPULDBLOCK错误。



非阻塞connect三个用途：

1. 我们可以把三路握手叠加在其他处理机上。完成一个connect要花费一个RTT时间，而RTT波动范围很大，从局域网上的几个毫秒到几百个毫秒甚至是广域网上的几秒。这段时间内也许有我们想要执行的其他处理工作可执行。
2. 我们可以使用这个技术同时建立多个连接
3. 既然使用select等待连接的建立，我们可以给select指定一个时间限制，使得我们能够缩短connect的超时

**非阻塞 connect 听起来虽然简单，但是仍然有一些细节问题要处理：**  

1.即使套接字是非阻塞的，如果连接的服务器在同一台主机上，那么在调用 connect 建立连接时，连接通常会立即建立成功。我们必须处理这种情况； 
2.源自 Berkeley 的实现有两条与 select 和非阻塞 I/O 相关的规则： 
  A) 当连接建立成功时，套接口描述符变成 **可写** （连接建立时，写缓冲区空闲，所以可写） ； 
  B) 当连接建立出错时，套接口描述符变成 **既可读又可写** （由于有未决的错误，从而可读又可写） ； 

1. 调用获取对端 socket 地址的 getpeername 代替 getsockopt 。如果调用 getpeername 失败，getpeername 返回 ENOTCONN ，表示连接建立失败，之后我们必须再以 SO_ERROR 调用 getsockopt 得到套接口描述符上的待处理错误； 
2. 调用 read ，读取长度为 0 字节的数据。如果连接建立失败，则 read 会返回 -1 ，且相应的 errno 指明了连接失败的原因；如果连接建立成功，read 应该返回 0 。 
3. 再调用一次 connect 。它应该失败，如果错误 errno 是 EISCONN ，就表示套接口已经建立，而且第一次连接是成功的；否则，连接就是失败的。 