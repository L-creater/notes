## 第六章	进程结构

### 6.1	进程状态和状态的转换

1. 进程在用户态下正在执行。
2. 进程在核心态下正在执行
3. 进程未被执行，但处于就绪态。只要内核调度它，即可执行
4. 进程正在睡眠并驻留在主存中
5. 进程处于就绪状态，但对换进程（进程0）必须把它换入主存，内核再能调度他去执行
6. 进程正在睡眠，而且对换进程已把它换到二级存储器，从而为其他进程腾出空间
7. 进程正从核心态返回用户态。但内核抢先于他，并做了上下文切换，以调度另一个进程
8. 进程刚被创建，处于变迁状态。该进程存在，但还没有就绪，也不再睡眠。这个状态是除进程0以外的所有进程的初始状态。
9. 进程执行了系统调用exit，处于僵死状态。该进程不再存在，但他留下一个记录，该记录可由其父进程收集，其中含有 出口码及一些及时统计信息。僵死状态是进程最后状态。



###  6.2	系统存储方案

#### 6.2.1	区

系统v的内核把一个进程的虚地址空间分成若干逻辑区。区是进程虚地址空间上的一段连续区域，可把这段区域看作是可被共享和保护的独立实体。

内核中有一个区表，每个在系统中活动的区对应于表中的一个表项。区的概念独立于存储管理策略。存储管理策略是由操作系统实施的。

#### 6.2.2	页和页表

在基于页的存储管理体系结构中，存储管理的硬件将物理存储器分为一些大小相等的块，称为页。典型的页面大小是从512字节到4k字节，具体多大有硬件决定。

内核将区中的逻辑页号映射为机器上的物理页号，从而使区的虚地址和它们的物理机器地址联系起来。在一个程序中由于区是连续的地址空间，所以逻辑页号就自然的成为一个物理页号数组的数组下标。

#### 6.2.3	内核的安排

尽管内核是在某个进程的上下文中执行，但与内核相联系的虚存映射却与所有进程都无关。内核的代码和数据永久的驻留在系统中，并被所有进程共享。

#### 6.2.4	u区

每个进程都有一个私有u区，然而，内核访问u区时，就好像系统中仅有一个u区，即正在运行的进程的u区。根据运行的进程，内核改变其虚拟地址转换的映射，已存取存取正确的u区。

一个进程在核心态运行时能够访问他的u区，但在用户态时却不能。

### 6.3	进程的上下文

进程的上下文是由其用户地址空间的内容、硬件寄存器内容以及与该进程有关的内核数据结构组成。更严格地说，进程的上下文是由他的用户级上下文、寄存器上下文、以及系统级上下文组成。

用户级上下文是由进程地正文、数据、用户栈和共享存储区组成。

寄存器上下文有下列组成：

- 程序计数器，指出CPU将要指向的下条指令的地址；该地址是内核中或用户存储空间的虚地址
- 处理机状态寄存器，给出机器与该进程相关联时的硬件状态。
- 栈指针，含有栈中下一项的当前地址。该地址是在核心栈中，还是在用户栈中，由运行方式来决定
- 通用寄存器，其中的数据是进程在其运行期间产生的

进程的系统级上下文由静态部分和动态部分组成。下面列出的组成部分，前三项是静态的，后三项是动态的。进程在整个生命周期，只有一个静态部分，但可以有可变数目的动态部分。

系统级上下文有下列部分组成：

- 一个进程的进程表表项，它定义了该进程的状态，并含有内核总能取到的控制信息。
- 一个进程的u区，其中含有进程的控制信息，这些信息只需要在该进程的上下文中被存取
- 本进程区表表项、区表及页表。他们定义了从虚地址到物理地址的映射，因而决定了进程的正文区、数据区、栈区和其他的区。
- 核心栈。当一个进程在核心态执行时，它含有内核过程的栈结构。尽管所有的进程执行相同的代码，但它们各有一份私有的核心栈拷贝。这个拷贝指出了他们对内核函数的特殊调用。
- 进程的系统级上下文的动态部分由一些“层”组成

###  6.4	进程上下文的保存

#### 6.4.1	中断和例外

内核处理中断的操作顺序是：

1. 对正在执行的进程，保存其当前寄存器上下文并创建（压入）一个新上下文层。
2. 确定中断源，识别终端类型（如时钟和磁盘）若可以的话还可以识别的单元号（如那个磁盘引起的中断）。当系统接收一个中断时，他从机器中得到一个数，系统把这个数用作查表的偏移量。这个表通常被称为中断向量。
3. 内核调用中断处理程序。
4. 中断处理程序工作完毕前返回

#### 6.4.2	系统调用的接口

系统调用是一个中断处理程序的特例。

#### 6.4.3	上下文切换

内核在四种情况下允许发生上下文切换：

- 当进程使自己进入睡眠时
- 当他从一个系统调用返回用户态但不是最有资格运行的进程时
- 当它在内核完成中断处理后返回用户态，但不是最有资格运行的进程时
- 当它退出时。

#### 6.4.4	为废弃返回而保存上下文

这种情况发生在内核必须中止它当前的执行顺序，立即从先前保存的上下文执行时。

#### 6.4.5	在系统和用户地址空间之间拷贝数据

将系统调用参数从用户空间拷贝到内核空间，或者，在系统调用read中，将I/O缓冲区的数据拷贝到用户空间。许多机器还允许内核直接地访问用户空间地址。内核必须知道正在读或写的用户空间地址是可存取的，就好像它一直在运行；否则，他可能破坏普通的写保护机制，无意地读、写用户地址空间之外的地址。

### 6.5	进程地址空间的管理

区表表项中含有描述一个区的必要信息，特别要指出的是下列字段：

- 指向文件的索引节点的指针。该文件的内容一开始被装入该区的数据。

- 区的类型（正文，共享存储区，私有数据或栈）。

- 区的大小

- 区的状态，可以是如下状态的组合

  ---锁住

  ---在请求中

  ---正在被装入内存的过程中

  ---有效，已被装入内存

- 引用数，给出引用该区的进程数 

#### 6.5.1	区的上锁和解锁

#### 6.5.2	区的分配

在系统调用fork，exec和shmget(共享存储区)期间，内核将分配一个新区。

#### 6.5.3	区附接到进程

在系统调用fork，exec和shmget(共享存储区)期间，内核要使一个区和一个进程的地址空间联系起来，称为附接。 

#### 6.5.4	区大小的改变

内核在内部调用算法growreg来改变区的大小。

内核将growreg用于已存在的区大小有两种情况：一种是用户栈的自动增长；一种是系统调用sbrk，它用于一个进程的数据区。这两种区都是私有的。正文区和共享存储区在初始化后不能再被拓展。

#### 6.5.5	区的装入

一个区附接到一个进程的虚地址上，在这个虚地址和该区数据的起始虚地址之间有一段间隙。为了将一个文件装入一个区，算法loadreg计算这个间隙的大小，并根据read算法的内部形式将该区数据从文件读入内存。

#### 6.5.6	区的释放

当一个区不再与任何进程相附接时，内核便释放该区并把他送回自由链表。如果该区和某个索引节点有关，内核就用算法iput释放该索引节点，这对应于算法allocreg中的索引节点引用数加1.内核释放与该区有关的资源，如页表和存储页。

#### 6.5.7	区与进程的断接

在系统调用exec,exit,shmdt中，内核使有关的区与进程相断接。

#### 6.5.8	区的复制

系统调用fork要求内核复制一个进程的所有区。然而，如果某个区是共享的(共享正文或共享存储区)，内核就不必物理的拷贝该区，而是增加该区的引用数，允许父进程和子进程共享该区。如果该区不是共享的，内核必须物理的拷贝该区。他分配一个新的区表表项、页表以及该区的物理存储空间。

### 6.6	睡眠

sleep 将进程的状态由核心态运行变为在内存中睡眠，而wakeup将进程状态由睡眠变为在内存中就绪或就绪且换出。

#### 6.6.1	睡眠事件及其地址

进程在一个事件上睡眠，意思是他们处于睡眠状态，知道该事件发生。当事件发生时，他们就醒来进入就绪状态。

#### 6.6.2	算法sleep和wakeup

