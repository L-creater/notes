## 第七章	进程控制

### 7.1 	进程控制

在UNIX操作系统中，用户创建一个新进程的唯一方法就是调用系统调用fork。调用fork的进程称为父进程，而创建的进程叫做子进程。系统调用的语法格式是：pid=fork();

内核为系统调用fork完成下列操作：

1. 为新进程在进程标中分配一个空槽
2. 为子进程赋一个唯一的进程标识号
3. 做一个父进程上下文的逻辑副本
4. 增加与该进程相关联的文件表和索引节点表的引用数。
5. 对父进程返回子进程的进程号；对子进程
6. 返回零

### 7.2	软中断信号

**软中断信号**（简称信号）通知进程发生了异步事件。进程之前可以通过系统调用kill相互发送软中断信号。内核也可以从内部发送软中断信号。

软中断的处理有以下几个方面：

- 内核如何向一个进程发软中断信号；
- 进程如何接收软中断信号；
- 进程如何控制自己对软中断信号的反应

当一个进程即将从核心态返回到用户态时，或他要进入或离开一个适当的低调度优先级睡眠状态时，内核要检查她是否收到了一个软中断信号。**内核仅当一个进程从核心态返回到用户态时才处理软中断信号。因此，当一个进程在核心态下运行时，软中断信号并不起作用。 **

#### 7.2.1	软中断信号处理

处理软中断信号有三种情况：

- 进程收到软中断信号后退出；
- 进程忽略信号
- 收到信号后执行一个特殊的函数

 

#### 7.2.2	进程组

尽管在UNIX中进程是以唯一的进程标识号所标识的，但系统有时必须用“组”来标识进程。

内核用进程组标识号来表识一组相关的进程。

可以利用setpgrp()初始化一个进程的进程组号，将其设置为与该进程标识号相同的值。

```
	grp = setpgrp();
```

在系统调用fork期间，子进程得到父进程的进程组号。setpgrp()在设置一个进程的控制终端上有重要的作用。

#### 7.2.3	从进程发送软中断信号

进程使用系统调用kill发送软中断信号。该系统调用语法格式为：

kill(pid, signum)

其中pid标识了一个接收软中断信号的进程集合。signum是要发送的软中断信号号。下面列出的是一组进程与pid之间的对应关系：

- 如果pid是正值，内核将信号发送给进程号为pid的进程。
- 如果pid为0，内核将信号发送给所有与发送进程同组的进程
- 如果pid为-1，内核将信号发给所有真正的用户标识号等于发送进程的有效用户标识号的进程。如果发送进程具有超级用户的有效用户标识号，则内核将信号发送给除进程0和进程1以外的所有进程。
- 如果pid为负但非-1.内核将信号发送给组号为pid绝对值的进程组中的所有进程。

### 7.3	进程的终止

UNIX系统中的进程执行系统调用exit来终止运行。

每个退出的进程进入僵死状态，释放它的资源，撤除进程上下文，但保留他的进程选项。系统调用exit语法格式为：

​	exit(status); 

其中status的值返回给父进程以便检查。进程可以显式地调用exit或在程序的结尾隐含地调用。

### 7.4	等待进程的终止

一个进程可以通过系统调用wait使它的执行与子进程终止同步。系统调用格式为：

​		pid=wait(stat_addr)

其中，pid是僵死子进程的进程号；stat_addr是一个整数在用户空间的地址，他将含有子进程的退出状态码。

**wait算法**



> 注释：如果执行wait的进程有子进程，但没有僵死进程，则其睡眠在可被中断的优先级上，知道出现一个软中断信号。
>
> 内核对于睡眠与系统调用wait上的进程没有显式的唤醒调用，这样的进程只有收到软中断信号时被唤醒。
>
> 

对“子进程死”外的任意软中断信号，进程将像前面那样做出反应，但是如果软中断信号是“子进程死”，该进程将采取不同的对策：

- 在缺省的情况下，进程从系统调用wait的睡眠中醒来。算法sleep将调用算法issig来检查软中断信号。其识别出子进程死的软中断信号的特殊情况，并返回“false”，接下来内核不为算法sleep做longjmp，而是返回系统调用wait。内核重新开始wait算法中的循环。？？？？

- 如果进程捕俘“子进程死”的软中断信号，内核就好像处理其他信号一样，安排调用用户的软中断信号处理子程序。

- 如果进程忽略“子进程死”的软中断信号，内核重新开始wait中的循环，释放僵死子进程的进程表项，然后寻找其他的子进程。

### 7.5	对其他程序的引用

系统调用exec引用另外一个程序，他用一个可执行文件的副本覆盖一个进程的存储空间。除了exec地参数之外，在exec调用之前存在的用户级上下文的内容，在exec调用后就不能再存取了。内核将exec参数从旧地址空间拷贝到新地址空间。这一系统调用语法格式是：

execve(filename, argv, envp)

其中，filename是要引用的可执行文件的文件名；argv是一个字符指针数组的指针，这组字符指针是可执行程序的参数。envp是另一个字符指针数组的指针，这一组字符指针是执行程序的环境。     

### 7.6	进程的用户标识号

内核将两个用户标识号与一个进程相关联。他们独立于进程标识号。这两个用户标识号分贝成为真正用户标识号和有效用户标识号，后者称为setuid。真正用户标识号标识负责运行进程的用户。有效用户标识号用于给新创建的文件赋所有权、检查文件的存取权限和检查通过系统调用kill向进程发送软中断信号的许可权限。当进程用exec执行一个setuid程序时，或当进程显示的调用系统调用setuid时，内核允许进程改变他的有效用户标识号。

### 7.7	改变进程的大小

通过系统调用brk，一个进程可以增加或减少其数据区的大小。brk的语法格式是：

```c
brk(endds);
//其中，endds将成为进程数据区的最高虚地址值(称为break值)。
//另一种方法是调用sbrk
oldendds=brk(increment);
//其中，increment为以子节为单位对当前break值的改变量；oldendds是调用前的break值。
```

> sbrk是一个调用brk的C语言库函数。
>
> - 如果调用的结果是增加进程的数据空间，则新分配的数据空间虚拟的接在老数据空间之后，及进程的虚拟地址空间连续的扩展到新分配的数据空间上。
> - 内核要检查新的进程大小是否小于系统的最大值，以及新的数据区与原分配的虚地址空间是否没有重叠。
> - 如果检查通过，则内核调用算法growreg分配额外的内存给数据区，并增加进程的大小字段。
> - 在一个兑换系统上，内核也试图为新的空间分配新的内存，并将其内容清零。
> - 如果在内存中没有空间了，内核则将进程换出以获得新的空间。
> - 如果进程调用brk来释放以前分配的空间，则内核要释放内存空间。如果进程存取释放了页面中的虚地址，则导致一个存储器错。

### 7.8	shell 程序

### 7.9	系统自举和进程init

系统管理员要通过"自举"过程来初始化一个处于非活动状态的系统。

自举的目的对所有机器都相同：将操作系统装入内存，并开始执行它。完成这一任务通常需要一系列步骤，因而称为自举。

 

## 第八章	进程调度和时间

### 8.1	进程调度

UNIX系统上的调度程序属于操作系统调度程序中常用的一种，叫做多级反馈循环调度。

这种调度算法的意思是，内核给进程分一个CPU时间片，抢先一个超过其时间片的进程，并把他反馈到若干优先级队列中的某一个队列。一个进程在它结束之前，可能需要多次通过”反馈循环“。当内核做上下文切换和恢复一个进程的上下文时，该进程从他原来被挂起的地方继续执行。

#### 8.1.1	算法

#### 8.1.2	调度参数

每个进程都有一个优先权字段 ，用于进程的调度。在用户态的进程的优先权是他最近使用CPU时间的函数。最近使用较多CPU时间的进程得到较低的优先权。进程优先权的范围分为两种---用户优先权和核心优先权。每种优先权有若干优先权值，每个优先权都有一个逻辑上与它相关联的进程队列。

具有用户级优先权的进程在它们从核心态返回到用户态时被抢先，而得到他们的用户级优先权；而据有核心级优先权的进程在算法sleep中得到核心级优先权。用户级优先权低于一个阈值，核心级优先高于该阈值。

#### 8.1.3	进程调度的例子

#### 8.1.4	进程优先权控制

使用系统调用nice：

```
nice(value);
```

进程可以自然地实行对他们的调度优先权的控制。这里，value被加到进程优先权值的计算公式中：

```c
priority=("recrnt CPU usage"/coustant) + (base priority) + (nice value)
```

系统调用nice按参数提供的值，增加或减少进程表中nice字段，尽管只有超级用户才能提供提高进程优先权的nice的值。

只有超级用户才能提供低于指定阈值的nice值。

#### 8.1.5	公平共享调度

公平共享调度的原则是将用户团体分为一些公平共享组。这样，每组的成员，相对于组中的其他进程而言，受到常规进程调度的限制。然而，系统将CPU时间按比例分给每个组，并不考虑组中成员的多少。

#### 8.1.6	实时处理

实时处理指的是对外部事件进行立即响应，从而，在该事件发生后的一个指定时间内，调度指定的进程去运行。

### 8.2	有关时间的系统调用

与时间有关的系统调用有：stime,time,times,alarm。头两个是关于全局的系统时间，后两个是关于单个进程的时间。

stime 允许超级用户将一个表示当前时间的值赋给一个内核全局变量：

```c
stime(pvalue);
//这里，pvalue指向一个以秒为单位的长整数时间，时钟中断程序每秒钟一次的是该变量加1。
```

time查询由stime所设置的时间：

```c
time(tloc);
//tloc指向一个用户进程用作返回值的单元，time从系统调用中返回这个值。
```

times给出调用进程在用户态和核心态执行时所花费的时间以及它的所有僵死进程在用户态和核心态执行时曾花费的累计时间。该调用的语法格式：

```c
times(tbuffer);
struct tms *tbuffer;

//这里，tms含有查询到的时间，它有下面的结构来定义：
struct tms
{
    //time_t是用于时间的数据结构
    time_t tms_utime;	//进程的用户时间
    time_t tms_stime;	//进程的内核时间
    time_t tms_cutime;	//子进程的用户时间
    time_t tms_cstime;	//子进程的内核时间
}
//times返回“从过去的一个任意时刻”开始所经过的时间，通常是系统初启的时间。
```

### 8.3	时钟

时钟中断处理程序的功能是：

- 重新启动时钟
- 按内部定时器有计划地调用内部的内核函数
- 对核心进程和用户进程提供运行直方图分析的能力
- 收集系统和进程记账及统计信息
- 计时
- 在有请求时，向进程发送闹钟软中断信号
- 定期的唤醒对换进程
- 控制进程的调度

#### 8.3.1	重新启动时钟

#### 8.3.2	系统的内部定时

​		内核将必要的信息存放在callout表中，该表含有当定时时间到时所要调用的函数名、该函数的一个参数以及时钟的滴答为单位的定时时间。

​		用户不能直接控制callout表中的表项；这些表项是由内核在需要时，用各种内核算法创建的。对callout表的表项，内核不是按他们被放入表中的先后次序排序，而是按他们各自的"启动时间"进行排序。

​		因为是按启动时间排序的，所以在callout表中，各表项的时间字段记录是前一表项启动后，到该表项被启动时的时间量。对于表中的某一给定的表项，其总的启动时间是从启动表项重的第一项直到改表项（包括该表项）的时间的总和。

#### 8.3.3	直方图分析

​		内核直方图分析给出了一种确定系统在用户态的执行时间与系统在核心态的执行时间之比，以及内核执行内核中的各个子程序所花费的时间的度量方法。内核直方图驱动程序在时钟中断之时，对系统活动进行采样，以便监视内核模块的相对性能。

在允许内核进行直方图分析时，时钟中断处理程序就调用直方图驱动程序的中断处理程序，他首先确定处理机在中断时是处于用户态还是核心态。如果是核心态，它使对应于程序计数器的一个内部计数器加1；如果是用户态，它使用用户执行计数器加1。用户进程可以读直方图驱动程序，来获得内核技术并做统计。

#### 8.3.4	记账和统计

每个进程在其u区中还有一个字段，记录所消耗的内核时间和用户时间。当处理时钟中断时，内核根据进程是在核心态运行，还是在用户态运行，来修改该运行进程在u区中对应的字段，父进程在其退出的子进程累加运行统计信息时，在系统调用wait中收集其子进程的统计信息。

每个进程在u区中还有一个让内核记录其内存使用情况的字段。当时钟中断一个运行时的进程时，内核计算一个进程使用的总内存数，该数是该进程私有存储区和它在共享存储区中所占的比例的函数。

#### 8.3.5	计时

内核在每个时钟中断时，是一个时间变量加1。系统的计时是以时钟滴答为单位，从系统自举之时开始。在使用系统调用time时 ，内核利用该时间变量返回一个时间值，并计算一个进程的总的运行时间。
