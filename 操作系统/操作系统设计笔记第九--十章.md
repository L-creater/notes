## 第九章	存储管理策略

### 9.1	对换

对换算法的描述包括三个部分：对换设备上的空间管理，将进程换出内存和将进程换入内存。

#### 9.1.1	对换空间的分配

对换设备是在一个磁盘的可配置段中的一个块设备。内核在对换设备上是以一组连续的磁盘块为单位来分配空间。对换设备上，空间的分配是短暂的，它依赖于进程调度的模型。驻留在对换设备上的进程，最终会迁回主存，从而释放他在对换设备上所占据的空间。

内核通过存放在内存的、称为"映射图"的表，来管理对换设备的空间。映射图也用于管理除对换设备以外的其他一些资源(例如：一些设备驱动程序)。它允许采用最先适配算法，分配一个资源中的连续”块“

映射图是一个数组。数组的每一项都含有一个可分配资源的地址和再改地址上可用的资源的单位数。

当释放资源时，内核根据地址找出它们在映射图中的相应位置。这是可能三种情况：

1. 被释放的资源完全填满映射图中的一个空洞：他们的地址在映射图中刚好能连接紧接其前和其后的那些表项。在这种情况下，内核将所释放的资源与已存在的表项合并，形成映射图中的一项。
2. 被释放的资源部分的填充映射图中的一个空洞：如果被释放的资源的地址紧接其前或其后的表项，内核根据释放资源修改相应的表项的地址和单位数量字段，映射图的项数不变。
3. 被释放的资源部份地填充一个空洞但并不连接映射图中的任何表项。这时，内核在映射图中建立一个新的表项，并插入到相应的位置上去。

#### 9.1.2	进程的换出



如果内核需要内存空间，他就换出进程，以下事件可引起进程的换出：

- 系统调用fork必须为子进程分配空间；
- 系统调用brk扩大一个进程的大小；
- 一个进程由于其栈的自然增长而变大；
- 为了运行以前被换出、而现在又应被换入的进程。其中，由fork引起的情况最为突出，他是唯一不能放弃被进程先前占据地内存映像空间的情况。

1. **系统调用fork的对换**

   在系统调用fork描述中，假定父进程找到了足够的内存空间以创建子进程的上下文。否则，内核将换出该进程但并不被释放（父）进程的内存映像所占据的内存。当换出完成后，子进程在对换设备上，父进程将子进程置为就绪状态，然后返回用户态。由于子进程处于就绪态，所以对换进程总会将其换入内存。内核在内存中总会调度它，这时子进程完成它的fork系统调用然后返回用户态。

2. **扩展对换**

​		如果进程需要内存比当前已分配给他的内存还多，不管这是由栈增长引起的还是由调用系统调用引起的，内核都要进行一次进程的扩展对换。

#### 9.1.3	进程的换入

进程0，即对换进程，是唯一的将进程从对换设备上换入内存的进程。在系统初始化结束时，对换进程进入一个无限循环，它的任务就是将进程换入或换出。 

如果对换进程必须换出一个进程，那么对换进程检查在内存的每一进程：僵死进程不用换出，因为僵死进程不占据任何物理存储；锁在内存中的进程也不能换出。内核换出正在睡眠的进程而不会是换出"就绪"进程。因为"就绪"进程很可能很快就调度上。选取哪一个睡眠进程来换出取决于进程的优先权和它在内存驻留的时间。如果内存中没有正在睡眠的进程，那么选择哪个"就绪"进程来换出就取决于进程nice的值和他在内存的驻留时间。

###  9.2	请求调页

局部化原理；工作集；最近最少使用；窗口；

#### 9.2.1	请求调页的数据结构

支持底层存储管理和请求调页的主要内核数据结构有4个：页表表项、磁盘块描述项、页面数据表和对换使用表。 

为支持请求调页而设的下列位字段：

- 有效位
- 访问位
- 修改位
- 写时拷贝位
- 年龄位

> 1. 内核上置有效位来指示该页的内容是有效的。当有效位没有被置上时，对该页的访问不见得一定是非法的。
> 2. 访问位只是最近是否有进程访问了该页。
> 3. 修改位指示最近是否有进程修改了该页的内容。
> 4. 写时拷贝位用于系统调用fork，指出当进程修改该页内容时内核必须为该页建立一个新的拷贝。
> 5. 内核通过管理年龄位来记录该页作为一个进程的工作集中的一员有多长时间了。

pfdata(页面数据表)描述了每个物理页。他以页号来索引。每一表项的字段有：

- 页状态，指示该页是对换设备上，或在可执行文件中；并指示DMA是否正在为该页服务(从对换设备上读数据)；还指示该页是否可重新分配。
- 引用该页的进程个数。这个引用数等于引用该页的有效表项数目。他可能不同于共享含有该页的那些区的进程数目。
- 逻辑设备和含有该页一个拷贝的块号。
- 指向在空闲页链表中其他pfdata表项的指针和指向一个也散列队列中的其他pfdata表项的指针。 



1.   调页系统中的系统调用fork

   在系统调用fork时，内核拷贝父进程的每个区，并将其附接到子进程上。

2. 调页系统中的系统调用exec

   当一个进程调用系统调用exec时，内核从文件系统中将可执行文件读入内存。但是在请求调页系统中，可执行文件可能因为太大而不能被全部装入可用的内存。所以内核并不为可执行文件预先分配内存，而是"假装的"认为文件已在内存，并随着需要而逐步分配内存。

####    9.2.2	偷页进程 

 偷页进程是一个核心进程，他将不再是进程工作集的页偷偷的换出内存。内核在系统初启时创建偷页进程，并在系统的生命周期内，每当有空闲页很少时调用它。偷页进程检查每一个活动的、非上锁的的区，跳过上锁的区，期待下遍扫描区链表时再检查它们，并增加所有有效页的年龄字段。当一个进程在一个区中出现有效性错，内核就锁住该区，这样偷页进程就不能将出错页换出。



内存中的页有两个调页状态：该页的年龄在增大，但还不能对换；或该页可被对换并可被重新分配给其他虚拟页。

第一种状态有若干字状态。当遍历超过了某个阈值时，内核就将该页置为第二种状态，即该页可被换出。---在可被换出之前，一个页面可被记龄的最大限度取决于实现。它受限于页表表项中可用位的位数。



当系统中可用的空闲存储低于某一低水准水平时，内核就唤醒偷页进程，偷页进程不断地将一些页换出，直到系统中可用的空闲存储超过某一高水准标志 。高水准标志和低水准标志的使用减少了抖动。

当偷页进程决定换出某页时，他考虑对换设备上是否已有该页的拷贝，这时有三种可能性：

- 如果对换设备上没有该页的拷贝，内核要"安排"换出该页：偷页进程将该页放到一个要换出的页面链上，然后继续运行，此次对换便逻辑的完成了。当换出的页面链达到一定限度时，内核便将这些页写到对换设备上去 。
- 如果该页的拷贝已在对换设备上，而且没有进程修改过他在内存中的内容，内核将该页表项的有效位清零，pfdata表项的引用数减1，并将该表项放入空闲链表以供进一步的分配
- 如果页面的拷贝已在对换设备上，并且进程已修改了该页面在内存中的内容，向上面一样，内核要安排换出该页，并释放它在对换设备上目前占据的空间。

#### 9.2.3	页面错

系统产生两种页面错：有效性错及保护错。因为页面错处理程序可能要将磁盘上的某页读入内存，并在I/O操作期间进入睡眠，所以，对于中断处理不能睡眠这个一般规则而言，页面错误处理程序是个例外。因为页面错误处理程序睡眠发生在存储错的进程上下文中，也就是说，页面错总是与正在运行的进程相关联，因此，不会使任意的其他进程进入睡眠。

- 有效性错处理程序


如果一个进程企图存取一个有效位为0的页，他将产生一个有效性错，内核要调用有效性错处理程序。

  引起出错的页面状态是下列五种状态之一：

1. 在对换设备上，且不在内存中
2. 在内存中的空闲链表上
3.  在一个可执行文件中
4. 标志"请求清零"
5. 标志"请求填入"

- 保护错处理程序

  第二类内存错，即进程引起的保护错，是进程试图存取一个许可位关闭的有效页面所产生的。

#### 9.2.4	再简单硬件支持下的请求调页系统

如果硬件能设置访问位和修改位，并且，当一个进程写一个设置了"写时拷贝"位的页面时，硬件能产生一个保护错，则请求调页的算法是最高效的。

如果硬件进能识别有效位和保护位，仍然可能实现我们在这里描述的算法，如果有效位被复制到一个软件有效位，它指示该页是真有效还是无效，则内核可以关闭硬件有效位，并用软见模拟来设置其他的指示位。

### 9.3	对换和请求调页的混合系统

​	尽管请求调页系统比对换系统更灵活地使用内存，但由于缺少内存，也可能产生偷页进程和有效性错处理程序抖动的现象。

系统V的内核同时运行对换和请求调页算法以避免抖动问题。

##   第十章	输入/输出子系统

输入/输出子系统是进程能与外围设备如磁盘、磁带、终端、打印机及网络进行通信，而控制设备的内核模块常称为设备驱动程序。通常设备驱动程序与设备类型是一一对应的：系统可以含有一个磁盘驱动程序以控制所有的磁盘；一个终端驱动程序控制所有的终端；一个磁带驱动程序控制所有的磁带。

系统支持"软设备"，软设备没有与之相关联的物理设备。

### 10.1	驱动程序接口

UNIX系统包含两类设备：块设备和原始(字符)设备。

块设备如磁盘和磁带，对系统的其余部分来说好像是随机存取的存储设备；字符设备包括所有的其他设备，如终端和网络介质。块设备也可以有一个字符设备接口。

用户通过文件系统与设备接口：每个设备有一个像文件名那样的名字，并对它象一个文件那样存取。

#### 10.1.1	系统配置

系统配置是系统管理员规定与装备有关的参数的过程。某些参数规定内核的大小，如进程表、索引节点表、文件表，以及分配给缓冲池的缓冲数目。

内核驱动程序的接口是由块设备开关表及字符设备开关表描述的。每一种设备类型在表中有若干表项这些表项在系统调用时引导内核转向适当的驱动程序入口。

 系统管理员用mknod命令建立设备特殊文件。命令中提供文件类型(块或字符设备)和主、次设备号，mknod命令调用系统调用mknod来产生设备文件。

#### 10.1.2	系统调用与驱动程序接口

1. 系统调用open 

   为了以系统调用open打开一个设备，内核使用与它打开正规文件同样的过程，即：分配一个内存索引节点，增加其引用计数，赋予一个文件表表项和用户文件描述符，内核最后将用户文件描述符返回给调用的进程。所以打开一个设备文件看上去就像打开一个正规文件 。然后返回到用户以前，调用设备专用的打开进程：对换设备，他调用块设备开关表中的打开过程；字符设备，他调用字符设备开关表中的打开过程。如果一个设备既是块设备又是字符设备，内核将根据用户所打开的特定的设备文件，调用适当的打开过程。

2. 系统调用close

   一个进程通过系统调用close断开他与一打开设备的连接。仅当该设备的最后一个关闭操作到来时，即没有其他进程仍然打开这该设备时，内核才调用那个设备专用的关闭过程。

   内核在释放索引节点之前，他进行设备文件专用操作：

   - 它搜索文件表以确定没有其他的进程仍然打开着该设备。根据文件表中的引用数来指示这是一个设备的最后一次操作是不够的，因为几个进程可以通过不同的文件表表项存取该设备；同样，依靠索引节点引用数也是不够的，因为几个设备文件可以表示同一设备。
   - 对于一个字符设备，内核调用设备的close过程并返回用户态。对于一个块设备，内核搜索安装表已确认该设备不包含一个已安装的文件系统。
   - 内核释放设备文件的索引节点

3. 系统调用read和write

4. 策略接口

5. 系统调用ioctl

###  10.2	磁盘驱动程序

### 10.3	终端驱动程序

终端驱动程序具有与其他驱动程序相同的功能，即控制从终端来和到终端去的数据。

#### 10.3.1	字符表clist

