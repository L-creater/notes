### 第七章	类

类的基本思想是**数据抽象**和**封装**。数据抽象是一种依赖于**接口**和**实现**分离的编程

#### 7.1	定义抽象数据类型

##### 7.1.1	设计Sales_data类

##### 7.1.2	定义改进的Sales_data类

**定义成员函数**

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。

**引入this**

成员函数通过一个名为**this**的额外的隐式参数来访问调用它的那个对象。

在成员函数内部，我们可以直接调用该函数的对象的成员，而无需通过成员访问运算符来做这一点，因为this 所指的正是这个对象。任何对类成员的直接访问都被看作this的隐式引用。

因为this的目的总是指向"这个"对象，所以this是一个常量指针，我们不允许改变this 中保存的地址。

**引入const成员函数**

c++的语言做法是允许吧const关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的const表示this是一个指向常量的指针。像这样使用const的成员函数被称作**常量成员函数**

**类作用域和成员函数**

类本身就是一个作用域。类的成员函数的定义嵌套在类的作用域之内。

**在类的外部定义成员函数**

**定义一个返回this对象的函数**

##### 7.1.3	定义类相关的非成员函数

> 一般来说，如果非成员函数是类的接口的组成部分，则这些函数的声明应该与类在同一个头文件内

```c++
istream &read(istream &is, Sales_data &item)
 {
     double price = 0;
     is >> item.bookNo >> item.units_sold >> price;
     item.revenue = price * item.units_sold;
     return is;

 }

 ostream &print(ostream &os, const Sales_data &item)
 {
     os << item.isbn() << " " << item.units_sold << " " << item.revenue << "  " << item.avg_price();
     return os;
 }
//read函数从给定流中将数据读到给定的对象里，print函数则负责将给定对象的内容打印到给定流中
```

- read和print分别接受一个各自IO类型的引用作为其参数，这是因为IO类属于不能被拷贝的类型，因此我们只能通过引用来传递他们。

##### 7.1.4	构造函数

构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。

**合成的默认构造函数**

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

**某些类不能依赖合成的默认构造函数**

