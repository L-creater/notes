## 6 函数

### 6.1 函数基础

**函数定义**

包括：返回类型，函数名字，由0个或多个形参组成的列表以及函数体。

我们通过调用运算符来执行函数。调用运算符的形式事一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔离的实参列表，我们用实参初始化函数的形参。

```c++
//编写函数
int fact(int val)
{
    int ret = 1;
    while (val > 1)
        ret *= val--;  //把ret和val的乘积赋给ret,然后将val减1
    return ret;
}

//调用函数
int main()
{
    int j = fact(5);
    cout<<"5! is" << j <<endl;
    return 0;
}
```

**形参和实参**

实参是形参的初始值。实参的类型必须与对应的形参类型匹配。

**函数的形参列表**

函数形参列表可以为空，但不能省略。

```c++
void f1()
{
    
}
void f2(void)
{
    
}
```

形参列表中的形参通常用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参类型一样，也必须把两个类型都写出来：


```c++
int f3(int v1,v2) {}//错误
int(int v1, int v2){}//正确
```

任意两个形参都不能重名，且函数最外层作用域中的局部变量也不使用与函数形参一样的名字。

**函数返回类型**

#### 6.1.1 局部对象

形参和函数体内部定义的变量统称为局部变量，仅在函数的作用域内可见，*同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。*

**自动对象**

只存在于块执行期间的对象称为**自动对象**。

形参是一种自动对象。

**局部静态对象**

某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部对象变量定义成static类型从而获得这样的对象。**局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在函数结束执行也不会对其产生影响。

```c++
size_t count_calls()
{
    static size_t ctr = 0; //函数调用结束后，这个值仍然有效
    return ++ctr;
}
int main()
{
    for(size_t i = 0; i!=10; ++i)
    {
        cout << count_calls() << endl;
    }
    return 0;
}
//这段程序将输出从1到10的数字
```

#### 6.1.2 函数声明

函数的名字必须在使用前声明。函数只能定义一次，可以声名多次。

**在头文件中进行函数声明**

含有函数声明的头文件应该包含到定义函数的源文件中。

#### *6.1.3 分离式编译*

**编译和链接多个源文件**

### 6.2 参数传递

当形参式引用类型，对应的实参被**引用传递**或者函数被**传引用调用**。**引用形参是它对应的实参的别名。**

当实参的值拷贝给形参时，形参和实参是两个相互独立的对象。这样的实参被**值传递**。

#### 6.2.1 传值参数

当初始化一个非引用的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。

```c++
int n=0;    //int  类型的初始变量
int i = n; 	//i是n的值的副本
i = 42;		//i的值改变，n不变
```

传值参数机理完全一样，函数对形参做的所有操作都不会影响实参。

***指针形参***

```c++
//
int n = 0, i = 42;
int *p = &n, *q = &i;		//p指向n;q指向i
*p = 42;					//n的值改变,p指向不变
p = q;						//p现在指向i,但i,n 值不变

```

指针形参行为与之类似：

```c++
//该函数接受一个指针，然后指针所指的位置为0
void reset(int *ip)
{
    *ip = 0;	//改变了指针ip所指对象的值
    
    ip = 0;		//只改变了ip的局部拷贝，实参未被改变
    
}

int i=42;
reset(&i);					//改变i的值而非i的地址
cout << "i = "<< i <<endl;	//输出i = 0


```

#### 6.2.2 传引用参数

引用操作实际上是作用在引用所引的对象上。

```c++
int n = 0, i = 42;
int &r = n;  //r绑定了n(即r是n的另一个名字)
r = 42;		 //现在n=42
r = i;		 //现在n的值和i的值相同
i = r;		 //i的值和n相同

```

引用形参与之类似

```c++
//该函数接受一个int对象的引用，然后将对象的值置0
void reset(&i)
{
	i = 0;    //改变了i所引用的对象的值
}

int j = 42;
reset(j);					//j采用传引用方式，它的值被改变。
cout << "J = "<< j <<endl;
```

**使用引用避免拷贝**

```c++
//我们准备编写写一个函数比较两个string对象的长度。因为string对象可能会非常长，所以应尽量避免直接拷贝它们，这时使用引用形参是
//比较明智的选择
//又因为比较长度无需改变string对象的内容，所以把形参定义成对常量的引用
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
```

**如果函数无须改变形参的值，最好将其声明为常量引用。**

**使用引用形参返回额外信息**

一个函数只能返回一个值，然而有时函数需要返回多个值，引用形参为我们提供了有效的途径

```c++
//定义find_char的函数，返回string对象中某个指定子覅第一次出现的位置，同时希望返回该字符出现总次数。

//返回s中c第一次出现的位置索引
//引用形参 occurs 负责统计c出现的总次数

string::size_type find_char(const string &s, char c, string::size_type &occurs)
{
    auto ret = s.size();	//第一次出现的位置（如果有）
    occurs =0;
    for(decltype(ret) i = 0;i != s.size(); ++i)
    {
        if(s[i] == c)
        {
            if(ret == s.size())
            {
                ret = i;  //记录c第一次出现位置
            }
            ++occurs;     //将出现的次数加1
        }
    }
    return ret;			  //出现次数通过occurs隐式返回
    
}

auto indes = find_char(s,'o',ctr);
```

#### 6.2.3 const 形参和实参

注意顶层const 的讨论

const修饰指针有三种情况

1. const修饰指针   --- 常量指针
2. const修饰常量   --- 指针常量
3. const即修饰指针，又修饰常量



**示例：**


```c++
int main() {

	int a = 10;
	int b = 10;

	//const修饰的是指针，指针指向可以改，指针指向的值不可以更改
	const int * p1 = &a; 
	p1 = &b; //正确
	//*p1 = 100;  报错
	

	//const修饰的是常量，指针指向不可以改，指针指向的值可以更改
	int * const p2 = &a;
	//p2 = &b; //错误
	*p2 = 100; //正确

    //const既修饰指针又修饰常量
	const int * const p3 = &a;
	//p3 = &b; //错误
	//*p3 = 100; //错误

	system("pause");

	return 0;
}
```



> 技巧：看const右侧紧跟着的是指针还是常量, 是指针就是常量指针，是常量就是指针常量